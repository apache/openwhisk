/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

buildscript {
    repositories {
        gradlePluginPortal()
        mavenCentral()
    }
    dependencies {
        classpath "gradle.plugin.cz.alenkacz:gradle-scalafmt:${gradle.scalafmt.version}"
    }
}

plugins {
    id "org.scoverage" version "7.0.0" apply false
    id "cz.alenkacz.gradle.scalafmt" version "1.16.2" apply false
}

subprojects {
    apply plugin: 'scalafmt'
    scalafmt.configFilePath = gradle.scalafmt.config

    group 'org.apache.openwhisk'
    version '1.0.1-SNAPSHOT'

    pluginManager.withPlugin('scala') {
        // Constraint all transitive pekko-* dependencies to the one we want to use to avoid issues.
        def cons = project.getDependencies().getConstraints()
        def pekko = ['pekko-actor', 'pekko-cluster', 'pekko-cluster-metrics', 'pekko-cluster-tools', 'pekko-coordination',
                    'pekko-discovery', 'discovery-kubernetes-api', 'discovery-marathon-api', 'pekko-distributed-data','grpc-runtime','pekko-protobuf', 'pekko-remote', 'pekko-slf4j',
                    'pekko-stream', 'pekko-stream-testkit', 'pekko-testkit', 'pekko-persistence', 'pekko-cluster-sharding','pekko-protobuf-v3','pekko-pki','pekko-serialization-jackson']
        def pekkoHttp = ['pekko-http', 'pekko-http-core', 'pekko-http-spray-json', 'pekko-http-testkit', 'pekko-http-xml',
                        'pekko-http2-support']
        def pekkoKafka = ['pekko-stream-kafka-testkit','pekko-connectors-kafka','pekko-connectors-s3','pekko-connectors-file']
        def pekkoManagement = ['pekko-management-cluster-bootstrap','pekko-management','pekko-discovery-kubernetes-api','pekko-discovery-marathon-api']

        pekko.forEach {
            cons.add('implementation', "org.apache.pekko:${it}_${gradle.scala.depVersion}:${gradle.pekko.version}")
        }
        pekkoHttp.forEach {
            cons.add('implementation', "org.apache.pekko:${it}_${gradle.scala.depVersion}:${gradle.pekko_http.version}")
        }
        pekkoKafka.forEach{
            cons.add('implementation', "org.apache.pekko:${it}_${gradle.scala.depVersion}:${gradle.pekko_kafka.version}")
        }
        pekkoManagement.forEach{
            cons.add('implementation', "org.apache.pekko:${it}_${gradle.scala.depVersion}:${gradle.pekko_management.version}")
        }
    }

    afterEvaluate {
        if (project.plugins.hasPlugin('scala')) {
            repositories {
                mavenCentral()
            }

            tasks.withType(ScalaCompile) {
                scalaCompileOptions.additionalParameters = gradle.scala.compileFlags
                scalaCompileOptions.forkOptions.jvmArgs = ["-Xss2m"]
            }

            if (project.plugins.hasPlugin('application')) {
                startScripts {
                    doLast {
                        unixScript.text = configureUnixClasspath(unixScript)
                    }
                }
            }

            configurations {
                implementationResolvable {
                    canBeResolved = true
                    canBeConsumed = false
                    extendsFrom configurations.implementation
                }
            }
        }

        if (project.plugins.hasPlugin('maven-publish')) {
            task sourcesJar(type: Jar, dependsOn: classes) {
                classifier = 'sources'
                from sourceSets.main.allSource
            }

            task testSourcesJar(type: Jar, dependsOn: testClasses) {
                classifier = 'test-sources'
                from sourceSets.test.allSource
                exclude("logback-test.xml")
            }

            task testClassesJar(type: Jar, dependsOn: testClasses) {
                classifier = 'tests'
                from sourceSets.test.output
            }
        }

        if (project.plugins.hasPlugin('application')) {
            //Ensure that dist archive name does not contain version
            distTar {
                archiveFileName = "${project.name}.tar"
            }

            //Avoid generating the zip files from maven installations
            distZip {
                enabled false
            }

            configurations.archives.artifacts.removeAll {it.file =~ 'zip'}
        }
    }
}

def configureUnixClasspath(File script) {
    script
        .readLines()
        .collect { line ->
            // Looking for the line that starts with CLASSPATH=
            line = line.replaceAll(~/^CLASSPATH=.*$/) { original ->

                // Get original line and append it
                // with the configuration directory.
                original += ':$APP_HOME/ext-lib/*:$APP_HOME/config'
                //Ensure classes comes first. Used to refer to instrumented classes for code coverage
                original = original.replace('CLASSPATH=', 'CLASSPATH=$APP_HOME/classes:')
            }
        }
        .join('\n')
}
